import { Wrap, Box } from "@chakra-ui/react";
import InlineCode from "../components/InlineCode";
import CodeBlock from "../components/CodeBlock";

# Scroll.Container

A scrollable container intended to wrap your scrollable content.

Often you will want this container to occupy the full size of the viewport, though it can be any width/height.

### Usage

```jsx
import { Scroll } from "scrollex";

export default function App() {
  return (
    <Scroll.Container scrollAxis="y" className="h-screen">
      <Scroll.Section>
        <h1>Section One</h1>
      </Scroll.Section>
      <Scroll.Section>
        <h1>Section Two</h1>
      </Scroll.Section>
      <Scroll.Section>
        <h1>Section Three</h1>
      </Scroll.Section>
    </Scroll.Container>
  );
}
```

### Props

Renders a div internally and accepts all props that a standard [motion.div](https://www.framer.com/docs/component/) would.

```tsx
interface ScrollContainerProps extends HTMLMotionProps<"div"> {
  scrollAxis?: "x" | "y";
  throttleAmount?: number;
}
```

#### scrollAxis

Specifies the scroll direction of the container.

```jsx
<Scroll.Container scrollAxis="x">
  <Scroll.Section>
    <h1>Section One</h1>
  </Scroll.Section>
</Scroll.Container>
```

#### throttleAmount

Throttle duration in milliseconds used to throttle scroll events which helps prevent animation interruptions.
You may wish to set this to `0` if animations are too sluggish/choppy for your liking. Default value is `90`.

```jsx
<Scroll.Container throttleAmount={0}>
  <Scroll.Section>
    <h1>Section One</h1>
  </Scroll.Section>
</Scroll.Container>
```

# Scroll.Section

Used to partition scrollable content and help you identify important keyframes. Sections perform layout measurements when they detect a change in their dimensions and then notify animations.

Because sections monitor their dimensions, their heights are allowed to change dynamically. This means for example that a section with `height: auto` will be able to adapt to changes to its content that cause the section to grow/shrink.

### Usage

```jsx
import { Scroll } from "scrollex";

export default function App() {
  return (
    <Scroll.Container scrollAxis="y" className="h-screen">
      <Scroll.Section>
        <h1>Section One</h1>
      </Scroll.Section>
      <Scroll.Section>
        <h1>Section Two</h1>
      </Scroll.Section>
      <Scroll.Section>
        <h1>Section Three</h1>
      </Scroll.Section>
    </Scroll.Container>
  );
}
```

### Props

Renders a div internally and accepts all props that a standard [motion.div](https://www.framer.com/docs/component/) would.

```tsx
interface ScrollSectionProps extends HTMLMotionProps<"div"> {}
```

# Scroll.Item

A container used to animate its content according to the current scroll position.

### Usage

```jsx
const keyframes = {
  heading: ({ section }) => ({
    [section.topAt("container-top")]: {
      rotateZ: "0deg",
    },
    [section.bottomAt("container-top")]: {
      rotateZ: "180deg",
    },
  }),
};

export default function App() {
  return (
    <Scroll.Container scrollAxis="y" className="h-screen">
      <Scroll.Section className="h-screen center">
        <Scroll.Item keyframes={keyframes.heading}>
          <h1>Page One</h1>
        </Scroll.Item>
      </Scroll.Section>
      <Scroll.Section className="h-screen center">
        <Scroll.Item keyframes={keyframes.heading}>
          <h1>Page Two</h1>
        </Scroll.Item>
      </Scroll.Section>
      <Scroll.Section className="h-screen center">
        <Scroll.Item keyframes={keyframes.heading}>
          <h1>Page Three</h1>
        </Scroll.Item>
      </Scroll.Section>
    </Scroll.Container>
  );
}
```

### Props

Renders a div internally and accepts all props that a standard [motion.div](https://www.framer.com/docs/component/) would.

```tsx
interface ScrollItemProps extends HTMLMotionProps<"div"> {
  keyframes?: KeyframesFn | KeyframesObj;
  springs?: SpringConfigs;
  data?: any;
}
```

#### keyframes

Can be either a function that returns a keyframes object or a keyframes object itself.

A keyframes object has the following form, where each key represents a scroll offset as a number of pixels
and each value represents the transformations that should be applied to the item when the user has scrolled the specified number of pixels.

```tsx
type KeyframesObj = Record<
  number,
  {
    scale?: number | string;
    scaleX?: number | string;
    scaleY?: number | string;
    scaleZ?: number | string;
    translateX?: number | string;
    translateY?: number | string;
    translateZ?: number | string;
    rotateX?: number | string;
    rotateY?: number | string;
    rotateZ?: number | string;
    skewX?: number | string;
    skewY?: number | string;
    opacity?: number | string;
    backgroundColor?: string;
    color?: string;
  }
>;
```

One thing to note is that scrollex restricts the properties which we can animate via keyframes for performance reasons.

`transform` and `opacity` are widely known to be the [safest properties to animate](https://web.dev/animations-guide/).

Scrollex also permits the animation of `color` and `backgroundColor` ([see example](https://codesandbox.io/s/scrollex-color-animations-q25h9g)).

To better understand how keyframes work, consider the following example.

```jsx
const keyframes = {
  heading: {
    [0]: {
      rotateZ: "0deg",
    },
    [200]: {
      rotateZ: "180deg",
    },
  },
};

export default function App() {
  return (
    <Scroll.Container scrollAxis="y" className="h-screen">
      <Scroll.Section className="h-screen center">
        <Scroll.Item keyframes={keyframes.heading}>
          <h1>Page One</h1>
        </Scroll.Item>
      </Scroll.Section>
      <Scroll.Section className="h-screen center">
        <Scroll.Item keyframes={keyframes.heading}>
          <h1>Page Two</h1>
        </Scroll.Item>
      </Scroll.Section>
      <Scroll.Section className="h-screen center">
        <Scroll.Item keyframes={keyframes.heading}>
          <h1>Page Three</h1>
        </Scroll.Item>
      </Scroll.Section>
    </Scroll.Container>
  );
}
```

The keyframes above dictate that once the user has scrolled down 200 pixels from the top of the container
then each heading should have a rotation of `180deg` applied.

If instead we pass a function to the `keyframes` prop (which we typcially will), then we'll have access to layout helpers that can help us calculate important keyframes.

```jsx
const keyframes = {
  heading: ({ section }) => ({
    [section.topAt("container-top")]: {
      rotateZ: "0deg",
    },
    [section.bottomAt("container-top")]: {
      rotateZ: "180deg",
    },
  }),
};

export default function App() {
  return (
    <Scroll.Container scrollAxis="y" className="h-screen">
      <Scroll.Section className="h-screen center">
        <Scroll.Item keyframes={keyframes.heading}>
          <h1>Page One</h1>
        </Scroll.Item>
      </Scroll.Section>
      <Scroll.Section className="h-screen center">
        <Scroll.Item keyframes={keyframes.heading}>
          <h1>Page Two</h1>
        </Scroll.Item>
      </Scroll.Section>
      <Scroll.Section className="h-screen center">
        <Scroll.Item keyframes={keyframes.heading}>
          <h1>Page Three</h1>
        </Scroll.Item>
      </Scroll.Section>
    </Scroll.Container>
  );
}
```

When passing a function to the `keyframes` prop, the function will be invoked with the following helpers.

```tsx
type KeyframesFn = (context: KeyframesContext) => KeyframesObj;

type KeyframesContext = {
  section: {
    topAt: (position: ContainerPositionY) => number;
    bottomAt: (position: ContainerPositionY) => number;
    leftAt: (position: ContainerPositionX) => number;
    rightAt: (position: ContainerPositionX) => number;
    width: number;
    height: number;
  };
  container: {
    width: number;
    height: number;
  };
  maxScrollPosition: number;
  data?: any;
};

type ContainerPositionY =
  | "container-top"
  | "container-center"
  | "container-bottom";

type ContainerPositionX =
  | "container-left"
  | "container-center"
  | "container-right";
```

#### springs

Internally each property (eg: `translateX`, `rotateZ`, `scale`) has an associated spring that controls its motion.

The `springs` prop accepts a `SpringConfigs` object which allows us to control the characteristics of these springs.

```jsx
const springs = {
  scale: {
    mass: 0.01,
    stiffness: 10,
    damping: 100,
  },
};

<Scroll.Item keyframes={keyframes.heading} springs={springs}>
  <h1>Page One</h1>
</Scroll.Item>;
```

`SpringConfigs` objects should have the following form.

```tsx
type SpringConfigs = {
  scale?: SpringOptions;
  scaleX?: SpringOptions;
  scaleY?: SpringOptions;
  scaleZ?: SpringOptions;
  translateX?: SpringOptions;
  translateY?: SpringOptions;
  translateZ?: SpringOptions;
  rotateX?: SpringOptions;
  rotateY?: SpringOptions;
  rotateZ?: SpringOptions;
  skewX?: SpringOptions;
  skewY?: SpringOptions;
  opacity?: SpringOptions;
  backgroundColor?: SpringOptions;
  color?: SpringOptions;
};

type SpringOptions = {
  stiffness?: number;
  damping?: number;
  mass?: number;
  restSpeed?: number;
  restDelta?: number;
};
```

The spring defaults are as follows.

```tsx
const DEFAULT_SPRING_CONFIGS = {
  translateX: {
    mass: 0.05,
    damping: 7.5,
    stiffness: 100,
  },
  translateY: {
    mass: 0.05,
    damping: 7.5,
    stiffness: 100,
  },
  translateZ: {
    mass: 0.05,
    damping: 7.5,
    stiffness: 100,
  },
  scale: {
    mass: 0.05,
    damping: 20,
    stiffness: 100,
  },
  scaleX: {
    mass: 0.05,
    damping: 20,
    stiffness: 100,
  },
  scaleY: {
    mass: 0.05,
    damping: 20,
    stiffness: 100,
  },
  scaleZ: {
    mass: 0.05,
    damping: 20,
    stiffness: 100,
  },
  skewX: {
    mass: 0.1,
    damping: 20,
    stiffness: 100,
  },
  skewY: {
    mass: 0.1,
    damping: 20,
    stiffness: 100,
  },
  rotateX: {
    mass: 0.05,
    damping: 7.5,
    stiffness: 100,
  },
  rotateY: {
    mass: 0.05,
    damping: 7.5,
    stiffness: 100,
  },
  rotateZ: {
    mass: 0.05,
    damping: 7.5,
    stiffness: 100,
  },
  opacity: {
    mass: 0.1,
    damping: 20,
    stiffness: 100,
  },
  backgroundColor: {
    mass: 0.05,
    damping: 7.5,
    stiffness: 100,
  },
  color: {
    mass: 0.05,
    damping: 7.5,
    stiffness: 100,
  },
};
```

#### data

The `data` prop allows us to pass through custom variables to the keyframes function.

One of the most practical uses of this is to [pass array indexes as a variable to a keyframes function](https://codesandbox.io/s/scrollex-staggered-reveal-cxiro5).

```jsx
const keyframes = {
  heading: ({ section, data }) => ({
    [section.topAt("container-top") + data.index * 200]: {
      opacity: 0,
    },
    [section.topAt("container-top") + data.index * 200 + 10]: {
      opacity: 1,
    },
  }),
};

const headings = ["Page One", "Page Two", "Page Three"];

export default function App() {
  return (
    <Scroll.Container scrollAxis="y" className="h-screen">
      <Scroll.Section className="h-[500vh]">
        <div className="sticky top-0 h-screen center">
          {headings.map((heading, index) => (
            <Scroll.Item
              key={heading}
              keyframes={keyframes.heading}
              data={{ index }}
            >
              <h1>{heading}</h1>
            </Scroll.Item>
          ))}
        </div>
      </Scroll.Section>
    </Scroll.Container>
  );
}
```

Through this method we can create a staggered effect as we scroll, revealing array items one after another.

# useScrollState

`useScrollState` lets you derive state from changes to the animation context.

The callback passed to `useScrollState` will be invoked whenever any of its parameters (animation context values) change.

Whenever the return value of the callback changes, the new return value will be set as react state, which in turn will cause the host component to rerender.

For this reason the return value of the callback must be a primitive value so that scrollex can use referential equality to determine if the return value has changed.

### Usage

See [sandbox](https://codesandbox.io/s/scrollex-usescrollstate-62xbv3?file=/src/App.tsx) for functional example.

```jsx
import { useScrollState } from "scrollex";

const useScrollDirection = () => {
  return useScrollState(({ velocity }) => {
    if (velocity > 0) {
      return "down";
    } else if (velocity < 0) {
      return "up";
    } else {
      return "static";
    }
  });
};
```

### Signature

`useScrollState` requires one parameter, a callback that should return a derived value.

Note that the state will always be `undefined` on the intial render as scrollex must perform layout measurements before it will invoke the callback.

```tsx
function useScrollState<T extends StateType>(
  callback: ScrollStateFn<T>
) => T | undefined;

type StateType = string | number | boolean | null | undefined;

type ScrollStateFn<T extends StateType> = (context: ScrollStateContext) => T;

type ScrollStateContext = {
  section: LayoutSection;
  container: LayoutContainer;
  maxScrollPosition: number;
  position: number;
  velocity: number;
};
```

# useScrollValue

`useScrollValue` returns a framer-motion `MotionValue` whose value is derived from changes to the animation context.

The callback passed to `useScrollValue` will be invoked whenever any of its parameters (animation context values) change.

Whenever the return value of the callback changes, the new return value will be set as the new value of the `MotionValue` that is returned from `useScrollValue`.

This is useful for controling low-level animations outside of the react render loop.

### Usage

See [sandbox](https://codesandbox.io/s/pointer-scrollable-graphic-l95fsb?file=/src/App.tsx) for functional example.

```jsx
import { useScrollValue } from "scrollex";

// Returns a MotionValue whose value ranges from [0, 1]
const useSectionProgress = () => {
  return useScrollValue(({ position, section, container }) => {
    const sectionPosition = position - section.topAt("container-top");
    const sectionScrollableHeight = section.height - container.height;
    const progress = sectionPosition / sectionScrollableHeight;
    return clamp(progress, 0, 1);
  });
};
```

### Signature

`useScrollState` requires one parameter, a callback that should return a derived value.

Note that the `MotionValue` will always have a value of `undefined` on the intial render as scrollex must perform layout measurements before it will invoke the callback.

```tsx
function useScrollValue<T extends number | string>(
  callback: ScrollValueFn<T>
) => MotionValue<T | undefined>;

type ScrollValueFn<T extends number | string> = (context: ScrollValueContext) => T;

type ScrollValueContext = {
  section: LayoutSection;
  container: LayoutContainer;
  maxScrollPosition: number;
  position: number;
  velocity: number;
};
```
